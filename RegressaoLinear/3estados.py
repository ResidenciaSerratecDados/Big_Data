# -*- coding: utf-8 -*-
"""3Estados.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11kRUCGhy2ppjKFR0ri-6EZwMWWG3qhPp
"""

!pip install --force-reinstall pandas

!pip install polars scikit-learn matplotlib

!pip install seaborn

from IPython import get_ipython
from IPython.display import display
import matplotlib.pyplot as plt
import seaborn as sns
import polars as pl
from datetime import datetime
import sys # Import the sys module
import os # Import the os module
from sklearn.linear_model import LinearRegression
import numpy as np
from sklearn.metrics import r2_score, mean_squared_error
import pandas as pd

# Define the file path
file_path = '/content/202501_NovoBolsaFamilia_polars.parquet'

# Load the parquet file into a Polars DataFrame
df = pl.read_parquet(file_path)

# Apply transformations using Polars expressions within with_columns
df = df.with_columns([
    # Convert the numeric month reference to datetime
    # First, ensure the column is string for datetime parsing
    pl.col('MÊS REFERÊNCIA').cast(pl.Utf8, strict=False).str.strptime(pl.Datetime, format='%Y%m', strict=False).alias('DATA_REF'),

    # Clean and convert 'VALOR PARCELA' to numeric
    pl.col('VALOR PARCELA').cast(pl.Utf8, strict=False).str.replace_all(',', '.', literal=True).cast(pl.Float64, strict=False).alias('VALOR')
])

# You might want to drop the original columns if no longer needed
# df = df.drop(['MÊS REFERÊNCIA', 'VALOR PARCELA']) # Uncomment if you want to drop original columns

# Verificar resultado
print(df.head())

# Corrected logic to select rows where 'UF' is in the list ['AC', 'SE', 'MS']
df_filtered = df.filter(
    pl.col('UF').is_in(['AC', 'SE', 'MS'])
)

# You might want to display or further process the filtered data
display(df_filtered.head(700000))

# Certifique-se que os dados estão corretamente agrupados
df_agrupado = df_filtered.group_by("DATA_REF").agg(
    pl.col("VALOR").mean().alias("VALOR_MEDIO").round(2)
).sort("DATA_REF")

# Converter para Pandas explicitamente
df_plot = df_agrupado.to_pandas()

# Verificar os dados que serão plotados
print("Dados para plotagem:")
print(df_plot.head())

# Configurar o estilo do seaborn
sns.set_theme(style="whitegrid")

# Criar a figura e o eixo explicitamente
fig, ax = plt.subplots(figsize=(12, 6))

# Plotar usando seaborn
sns.lineplot(
    data=df_plot,
    x="DATA_REF",
    y="VALOR_MEDIO",
    ax=ax,  # Especificar o eixo
    marker='o',  # Adicionar marcadores
    linewidth=2.5  # Tornar a linha mais visível
)

# Configurações adicionais
ax.set_title("Valor Médio do Bolsa Família ao Longo do Tempo", pad=20)
ax.set_xlabel("Mês de Referência", labelpad=10)
ax.set_ylabel("Valor Médio (R$)", labelpad=10)
ax.tick_params(axis='x', rotation=45)  # Rotacionar labels do eixo x

# Ajustar layout para evitar cortes
plt.tight_layout()
plt.show()

# 1. Converter para tipo Date do Polars se necessário
if df_agrupado["DATA_REF"].dtype != pl.Date:
    df_agrupado = df_agrupado.with_columns(
        pl.col("DATA_REF").cast(pl.Date)
    )

# 2. Calcular usando expressões puras do Polars
df_reg = df_agrupado.with_columns(
    (pl.col("DATA_REF").dt.year() * 12 + pl.col("DATA_REF").dt.month() -
     (pl.col("DATA_REF").min().dt.year() * 12 + pl.col("DATA_REF").min().dt.month()))
    .alias("MESES_DESDE_INICIO")
)

# 3. Verificar o resultado
print(df_reg.select(["DATA_REF", "MESES_DESDE_INICIO"]).head())

## 1. Preparar os dados para o modelo
# Converter para arrays numpy
X = df_reg["MESES_DESDE_INICIO"].to_numpy().reshape(-1, 1)  # Variável independente (meses)
y = df_reg["VALOR_MEDIO"].to_numpy()                        # Variável dependente (valor)

## 2. Criar e treinar o modelo
modelo = LinearRegression()
modelo.fit(X, y)

# Coeficientes do modelo
inclinacao = modelo.coef_[0]
intercepto = modelo.intercept_

print(f"Equação da reta: VALOR_MEDIO = {inclinacao:.2f} * MESES_DESDE_INICIO + {intercepto:.2f}")
print(f"Coeficiente angular (R$/mês): {inclinacao:.2f}")
print(f"Intercepto (valor inicial): R$ {intercepto:.2f}")

## 3. Fazer previsões
y_pred = modelo.predict(X)

## 4. Avaliar o modelo

r2 = r2_score(y, y_pred)
mse = mean_squared_error(y, y_pred)

print(f"\nMétricas de avaliação:")
print(f"Coeficiente de Determinação (R²): {r2:.4f}")
print(f"Erro Quadrático Médio (MSE): {mse:.2f}")

## 5. Visualização dos resultados
plt.figure(figsize=(10, 6))

# Plotar dados reais
plt.scatter(X, y, color='blue', label='Dados Reais')

# Plotar linha de regressão
plt.plot(X, y_pred, color='red', linewidth=2, label=f'Regressão: y = {inclinacao:.2f}x + {intercepto:.2f}')

# Configurações do gráfico
plt.title('Regressão Linear: Valor Médio vs Tempo (Meses)')
plt.xlabel('Meses desde o início')
plt.ylabel('Valor Médio (R$)')
plt.grid(True)
plt.legend()

# Mostrar gráfico
plt.tight_layout()
plt.show()

# Versão Alternativa com intervalo de confiança:

plt.figure(figsize=(10, 6))
sns.regplot(x=X.flatten(), y=y, ci=95,
            line_kws={'color': 'red', 'label': f'y = {inclinacao:.2f}x + {intercepto:.2f}'})
plt.title('Regressão Linear com Intervalo de Confiança 95%')
plt.xlabel('Meses desde o início')
plt.ylabel('Valor Médio (R$)')
plt.legend()
plt.grid(True)
plt.show()

#Gráfico individual para cada estado

acre = df_filtered.filter(
    pl.col('UF').is_in(['AC'])
)
sergipe = df_filtered.filter(
    pl.col('UF').is_in(['SE'])
)
mato_grosso_sul = df_filtered.filter(
    pl.col('UF').is_in(['MS'])
)

#ACRE

# Certifique-se que os dados estão corretamente agrupados
df_agrupado_AC = acre.group_by("DATA_REF").agg(
    pl.col("VALOR").mean().alias("VALOR_MEDIO").round(2)
).sort("DATA_REF")

# Converter para Pandas explicitamente
df_plot_AC = df_agrupado_AC.to_pandas()

# Verificar os dados que serão plotados
print("Dados para plotagem:")
print(df_plot_AC.head())

# Configurar o estilo do seaborn
sns.set_theme(style="whitegrid")

# Criar a figura e o eixo explicitamente
fig, ax = plt.subplots(figsize=(12, 6))

# Plotar usando seaborn
sns.lineplot(
    data=df_plot_AC,
    x="DATA_REF",
    y="VALOR_MEDIO",
    ax=ax,  # Especificar o eixo
    marker='o',  # Adicionar marcadores
    linewidth=2.5  # Tornar a linha mais visível
)

# Configurações adicionais
ax.set_title("Valor Médio do Bolsa Família - Acre", pad=20)
ax.set_xlabel("Mês de Referência", labelpad=10)
ax.set_ylabel("Valor Médio (R$)", labelpad=10)
ax.tick_params(axis='x', rotation=45)  # Rotacionar labels do eixo x

# Ajustar layout para evitar cortes
plt.tight_layout()
plt.show()

# 1. Converter para tipo Date do Polars se necessário
if df_agrupado_AC["DATA_REF"].dtype != pl.Date:
    df_agrupado_AC = df_agrupado_AC.with_columns(
        pl.col("DATA_REF").cast(pl.Date)
    )

# 2. Calcular usando expressões puras do Polars
df_reg_AC = df_agrupado_AC.with_columns(
    (pl.col("DATA_REF").dt.year() * 12 + pl.col("DATA_REF").dt.month() -
     (pl.col("DATA_REF").min().dt.year() * 12 + pl.col("DATA_REF").min().dt.month()))
    .alias("MESES_DESDE_INICIO")
)

# 3. Verificar o resultado
print(df_reg_AC.select(["DATA_REF", "MESES_DESDE_INICIO"]).head())

## 1. Preparar os dados para o modelo
# Converter para arrays numpy
X = df_reg_AC["MESES_DESDE_INICIO"].to_numpy().reshape(-1, 1)  # Variável independente (meses)
y = df_reg_AC["VALOR_MEDIO"].to_numpy()                        # Variável dependente (valor)

## 2. Criar e treinar o modelo
modelo_AC = LinearRegression()
modelo_AC.fit(X, y)

# Coeficientes do modelo
inclinacao_AC = modelo_AC.coef_[0]
intercepto_AC = modelo_AC.intercept_

print(f"Equação da reta: VALOR_MEDIO = {inclinacao_AC:.2f} * MESES_DESDE_INICIO + {intercepto_AC:.2f}")
print(f"Coeficiente angular (R$/mês): {inclinacao_AC:.2f}")
print(f"Intercepto (valor inicial): R$ {intercepto_AC:.2f}")

## 3. Fazer previsões
y_pred_AC = modelo_AC.predict(X)

## 4. Avaliar o modelo

r2_AC = r2_score(y, y_pred_AC)
mse_AC = mean_squared_error(y, y_pred_AC)

print(f"\nMétricas de avaliação:")
print(f"Coeficiente de Determinação (R²): {r2_AC:.4f}")
print(f"Erro Quadrático Médio (MSE): {mse_AC:.2f}")

## 5. Visualização dos resultados
plt.figure(figsize=(10, 6))

# Plotar dados reais
plt.scatter(X, y, color='blue', label='Dados Reais')

# Plotar linha de regressão
plt.plot(X, y_pred_AC, color='red', linewidth=2, label=f'Regressão: y = {inclinacao_AC:.2f}x + {intercepto_AC:.2f}')

# Configurações do gráfico
plt.title('Regressão Linear: Valor Médio vs Tempo (Meses) - Acre')
plt.xlabel('Meses desde o início')
plt.ylabel('Valor Médio (R$)')
plt.grid(True)
plt.legend()

# Mostrar gráfico
plt.tight_layout()
plt.show()

# Versão Alternativa com intervalo de confiança:

plt.figure(figsize=(10, 6))
sns.regplot(x=X.flatten(), y=y, ci=95,
            line_kws={'color': 'red', 'label': f'y = {inclinacao_AC:.2f}x + {intercepto_AC:.2f}'})
plt.title('Regressão Linear com Intervalo de Confiança 95% - Acre')
plt.xlabel('Meses desde o início')
plt.ylabel('Valor Médio (R$)')
plt.legend()
plt.grid(True)
plt.show()

#SERGIPE

# Certifique-se que os dados estão corretamente agrupados
df_agrupado_SE = sergipe.group_by("DATA_REF").agg(
    pl.col("VALOR").mean().alias("VALOR_MEDIO").round(2)
).sort("DATA_REF")

# Converter para Pandas explicitamente
df_plot_SE = df_agrupado_SE.to_pandas()

# Verificar os dados que serão plotados
print("Dados para plotagem:")
print(df_plot_SE.head())

# Configurar o estilo do seaborn
sns.set_theme(style="whitegrid")

# Criar a figura e o eixo explicitamente
fig, ax = plt.subplots(figsize=(12, 6))

# Plotar usando seaborn
sns.lineplot(
    data=df_plot_SE,
    x="DATA_REF",
    y="VALOR_MEDIO",
    ax=ax,  # Especificar o eixo
    marker='o',  # Adicionar marcadores
    linewidth=2.5  # Tornar a linha mais visível
)

# Configurações adicionais
ax.set_title("Valor Médio do Bolsa Família - Sergipe", pad=20)
ax.set_xlabel("Mês de Referência", labelpad=10)
ax.set_ylabel("Valor Médio (R$)", labelpad=10)
ax.tick_params(axis='x', rotation=45)  # Rotacionar labels do eixo x

# Ajustar layout para evitar cortes
plt.tight_layout()
plt.show()

# 1. Converter para tipo Date do Polars se necessário
if df_agrupado_SE["DATA_REF"].dtype != pl.Date:
    df_agrupado_SE = df_agrupado_SE.with_columns(
        pl.col("DATA_REF").cast(pl.Date)
    )

# 2. Calcular usando expressões puras do Polars
df_reg_SE = df_agrupado_SE.with_columns(
    (pl.col("DATA_REF").dt.year() * 12 + pl.col("DATA_REF").dt.month() -
     (pl.col("DATA_REF").min().dt.year() * 12 + pl.col("DATA_REF").min().dt.month()))
    .alias("MESES_DESDE_INICIO")
)

# 3. Verificar o resultado
print(df_reg_SE.select(["DATA_REF", "MESES_DESDE_INICIO"]).head())

## 1. Preparar os dados para o modelo
# Converter para arrays numpy
X = df_reg_SE["MESES_DESDE_INICIO"].to_numpy().reshape(-1, 1)  # Variável independente (meses)
y = df_reg_SE["VALOR_MEDIO"].to_numpy()                        # Variável dependente (valor)

## 2. Criar e treinar o modelo
modelo_SE = LinearRegression()
modelo_SE.fit(X, y)

# Coeficientes do modelo
inclinacao_SE = modelo_SE.coef_[0]
intercepto_SE = modelo_SE.intercept_

print(f"Equação da reta: VALOR_MEDIO = {inclinacao_SE:.2f} * MESES_DESDE_INICIO + {intercepto_SE:.2f}")
print(f"Coeficiente angular (R$/mês): {inclinacao_SE:.2f}")
print(f"Intercepto (valor inicial): R$ {intercepto_SE:.2f}")

## 3. Fazer previsões
y_pred_SE = modelo_SE.predict(X)

## 4. Avaliar o modelo

r2_SE = r2_score(y, y_pred_SE)
mse_SE = mean_squared_error(y, y_pred_SE)

print(f"\nMétricas de avaliação:")
print(f"Coeficiente de Determinação (R²): {r2_SE:.4f}")
print(f"Erro Quadrático Médio (MSE): {mse_SE:.2f}")

## 5. Visualização dos resultados
plt.figure(figsize=(10, 6))

# Plotar dados reais
plt.scatter(X, y, color='blue', label='Dados Reais')

# Plotar linha de regressão
plt.plot(X, y_pred_SE, color='red', linewidth=2, label=f'Regressão: y = {inclinacao_SE:.2f}x + {intercepto_SE:.2f}')

# Configurações do gráfico
plt.title('Regressão Linear: Valor Médio vs Tempo (Meses) - Sergipe')
plt.xlabel('Meses desde o início')
plt.ylabel('Valor Médio (R$)')
plt.grid(True)
plt.legend()

# Mostrar gráfico
plt.tight_layout()
plt.show()

# Versão Alternativa com intervalo de confiança:

plt.figure(figsize=(10, 6))
sns.regplot(x=X.flatten(), y=y, ci=95,
            line_kws={'color': 'red', 'label': f'y = {inclinacao_SE:.2f}x + {intercepto_SE:.2f}'})
plt.title('Regressão Linear com Intervalo de Confiança 95% - Sergipe')
plt.xlabel('Meses desde o início')
plt.ylabel('Valor Médio (R$)')
plt.legend()
plt.grid(True)
plt.show()

#MATO GROSSO DO SUL

# Certifique-se que os dados estão corretamente agrupados
df_agrupado_MS = mato_grosso_sul.group_by("DATA_REF").agg(
    pl.col("VALOR").mean().alias("VALOR_MEDIO").round(2)
).sort("DATA_REF")

# Converter para Pandas explicitamente
df_plot_MS = df_agrupado_MS.to_pandas()

# Verificar os dados que serão plotados
print("Dados para plotagem:")
print(df_plot_MS.head())

# Configurar o estilo do seaborn
sns.set_theme(style="whitegrid")

# Criar a figura e o eixo explicitamente
fig, ax = plt.subplots(figsize=(12, 6))

# Plotar usando seaborn
sns.lineplot(
    data=df_plot_MS,
    x="DATA_REF",
    y="VALOR_MEDIO",
    ax=ax,  # Especificar o eixo
    marker='o',  # Adicionar marcadores
    linewidth=2.5  # Tornar a linha mais visível
)

# Configurações adicionais
ax.set_title("Valor Médio do Bolsa Família - Mato Grosso do Sul", pad=20)
ax.set_xlabel("Mês de Referência", labelpad=10)
ax.set_ylabel("Valor Médio (R$)", labelpad=10)
ax.tick_params(axis='x', rotation=45)  # Rotacionar labels do eixo x

# Ajustar layout para evitar cortes
plt.tight_layout()
plt.show()

# 1. Converter para tipo Date do Polars se necessário
if df_agrupado_MS["DATA_REF"].dtype != pl.Date:
    df_agrupado_MS = df_agrupado_MS.with_columns(
        pl.col("DATA_REF").cast(pl.Date)
    )

# 2. Calcular usando expressões puras do Polars
df_reg_MS = df_agrupado_MS.with_columns(
    (pl.col("DATA_REF").dt.year() * 12 + pl.col("DATA_REF").dt.month() -
     (pl.col("DATA_REF").min().dt.year() * 12 + pl.col("DATA_REF").min().dt.month()))
    .alias("MESES_DESDE_INICIO")
)

# 3. Verificar o resultado
print(df_reg_MS.select(["DATA_REF", "MESES_DESDE_INICIO"]).head())

## 1. Preparar os dados para o modelo
# Converter para arrays numpy
X = df_reg_MS["MESES_DESDE_INICIO"].to_numpy().reshape(-1, 1)  # Variável independente (meses)
y = df_reg_MS["VALOR_MEDIO"].to_numpy()                        # Variável dependente (valor)

## 2. Criar e treinar o modelo
modelo_MS = LinearRegression()
modelo_MS.fit(X, y)

# Coeficientes do modelo
inclinacao_MS = modelo_MS.coef_[0]
intercepto_MS = modelo_MS.intercept_

print(f"Equação da reta: VALOR_MEDIO = {inclinacao_MS:.2f} * MESES_DESDE_INICIO + {intercepto_MS:.2f}")
print(f"Coeficiente angular (R$/mês): {inclinacao_MS:.2f}")
print(f"Intercepto (valor inicial): R$ {intercepto_MS:.2f}")

## 3. Fazer previsões
y_pred_MS = modelo_SE.predict(X)

## 4. Avaliar o modelo

r2_MS = r2_score(y, y_pred_MS)
mse_MS = mean_squared_error(y, y_pred_MS)

print(f"\nMétricas de avaliação:")
print(f"Coeficiente de Determinação (R²): {r2_MS:.4f}")
print(f"Erro Quadrático Médio (MSE): {mse_MS:.2f}")

## 5. Visualização dos resultados
plt.figure(figsize=(10, 6))

# Plotar dados reais
plt.scatter(X, y, color='blue', label='Dados Reais')

# Plotar linha de regressão
plt.plot(X, y_pred_MS, color='red', linewidth=2, label=f'Regressão: y = {inclinacao_MS:.2f}x + {intercepto_MS:.2f}')

# Configurações do gráfico
plt.title('Regressão Linear: Valor Médio vs Tempo (Meses) - Mato Grosso do Sul')
plt.xlabel('Meses desde o início')
plt.ylabel('Valor Médio (R$)')
plt.grid(True)
plt.legend()

# Mostrar gráfico
plt.tight_layout()
plt.show()

# Versão Alternativa com intervalo de confiança:

plt.figure(figsize=(10, 6))
sns.regplot(x=X.flatten(), y=y, ci=95,
            line_kws={'color': 'red', 'label': f'y = {inclinacao_MS:.2f}x + {intercepto_MS:.2f}'})
plt.title('Regressão Linear com Intervalo de Confiança 95% - Mato Grosso do Sul')
plt.xlabel('Meses desde o início')
plt.ylabel('Valor Médio (R$)')
plt.legend()
plt.grid(True)
plt.show()