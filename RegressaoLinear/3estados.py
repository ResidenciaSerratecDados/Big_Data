# -*- coding: utf-8 -*-
"""3Estados.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11kRUCGhy2ppjKFR0ri-6EZwMWWG3qhPp
"""

!pip install --force-reinstall pandas

!pip install polars scikit-learn matplotlib

!pip install seaborn

from IPython import get_ipython
from IPython.display import display
import matplotlib.pyplot as plt
import seaborn as sns
import polars as pl
from datetime import datetime
import sys # Import the sys module
import os # Import the os module
from sklearn.linear_model import LinearRegression
import numpy as np
from sklearn.metrics import r2_score, mean_squared_error
import pandas as pd

# 1 - SELEÇÃO E PREPARAÇÃO DE DADOS

# Define the file path
file_path = '/content/202501_NovoBolsaFamilia_polars.parquet'

# Load the parquet file into a Polars DataFrame
df = pl.read_parquet(file_path)

# Apply transformations using Polars expressions within with_columns
df = df.with_columns([
    # Convert the numeric month reference to datetime
    # First, ensure the column is string for datetime parsing
    pl.col('MÊS REFERÊNCIA').cast(pl.Utf8, strict=False).str.strptime(pl.Datetime, format='%Y%m', strict=False).alias('DATA_REF'),

    # Clean and convert 'VALOR PARCELA' to numeric
    pl.col('VALOR PARCELA').cast(pl.Utf8, strict=False).str.replace_all(',', '.', literal=True).cast(pl.Float64, strict=False).alias('VALOR')
])

# You might want to drop the original columns if no longer needed
# df = df.drop(['MÊS REFERÊNCIA', 'VALOR PARCELA']) # Uncomment if you want to drop original columns

# Verificar resultado
print(df.head())

# Corrected logic to select rows where 'UF' is in the list ['AC', 'SE', 'MS']
df_filtered = df.filter(
    pl.col('UF').is_in(['AC', 'SE', 'MS'])
)

# You might want to display or further process the filtered data
display(df_filtered.head(700000))

acre = df_filtered.filter(
    pl.col('UF').is_in(['AC'])
)
sergipe = df_filtered.filter(
    pl.col('UF').is_in(['SE'])
)
mato_grosso_sul = df_filtered.filter(
    pl.col('UF').is_in(['MS'])
)

# 2 - ANALISE DESCRITIVA

# Certifique-se que os dados estão corretamente agrupados
df_agrupado = df_filtered.group_by("DATA_REF").agg(
    pl.col("VALOR").min().alias("VALOR_MINIMO").round(2),
    pl.col("VALOR").mean().alias("VALOR_MEDIO").round(2),
    pl.col("VALOR").max().alias("VALOR_MAXIMO").round(2),
    pl.col("NIS FAVORECIDO").count().alias("BENEFICIARIO").round(2)
).sort("DATA_REF")

# Converter para Pandas explicitamente
df_plot = df_agrupado.to_pandas()

# Verificar os dados que serão plotados
print("Dados para plotagem:")
print(df_plot.head())

# Configurar o estilo do seaborn
sns.set_theme(style="whitegrid")

# Criar a figura e o eixo explicitamente
fig, ax = plt.subplots(figsize=(12, 6))

# Plotar usando seaborn, chamando lineplot for each desired column
sns.lineplot(
    data=df_plot,
    x="DATA_REF",
    y="VALOR_MINIMO", # Change 'VALORES' to 'VALOR_MINIMO'
    ax=ax,  # Especificar o eixo
    marker='o',  # Adicionar marcadores
    linewidth=2.5,  # Tornar a linha mais visível
    label='Valor Mínimo' # Add a label for the legend
)

sns.lineplot(
    data=df_plot,
    x="DATA_REF",
    y="VALOR_MEDIO", # Change 'VALORES' to 'VALOR_MEDIO'
    ax=ax,  # Especificar o eixo
    marker='o',  # Adicionar marcadores
    linewidth=2.5,  # Tornar a linha mais visível
    label='Valor Médio' # Add a label for the legend
)

sns.lineplot(
    data=df_plot,
    x="DATA_REF",
    y="VALOR_MAXIMO", # Change 'VALORES' to 'VALOR_MAXIMO'
    ax=ax,  # Especificar o eixo
    marker='o',  # Adicionar marcadores
    linewidth=2.5,  # Tornar a linha mais visível
    label='Valor Máximo' # Add a label for the legend
)

# Configurações adicionais
ax.set_title("Valores Mínimo, Médio e Máximo do Bolsa Família ao Longo do Tempo", pad=20)
ax.set_xlabel("Mês de Referência", labelpad=10)
ax.set_ylabel("Valores (R$)", labelpad=10)
ax.tick_params(axis='x', rotation=45)  # Rotacionar labels do eixo x

# Adicionar legenda
ax.legend()

# Ajustar layout para evitar cortes
plt.tight_layout()
plt.show()

sns.barplot(
    data=df_plot,
    x="DATA_REF",
    y="BENEFICIARIO", # Change 'VALORES' to 'Beneficiário'
    ax=ax,  # Especificar o eixo
)

# Configurações adicionais
ax.set_title("Quantidade de Beneficiários do Bolsa Família ao Longo do Tempo", pad=20)
ax.set_xlabel("Mês de Referência", labelpad=10)
ax.set_ylabel("Beneficiários", labelpad=10)
ax.tick_params(axis='x', rotation=45)  # Rotacionar labels do eixo x

# Ajustar layout para evitar cortes
plt.tight_layout()
plt.show()

# Certifique-se que os dados estão corretamente agrupados
df_agrupado_AC = acre.group_by("DATA_REF").agg(
    pl.col("VALOR").min().alias("VALOR_MINIMO").round(2),
    pl.col("VALOR").mean().alias("VALOR_MEDIO").round(2),
    pl.col("VALOR").max().alias("VALOR_MAXIMO").round(2),
    pl.col("NIS FAVORECIDO").count().alias("BENEFICIARIO").round(2)
).sort("DATA_REF")

# Converter para Pandas explicitamente
df_plot_AC = df_agrupado_AC.to_pandas()

# Verificar os dados que serão plotados
print("Dados para plotagem:")
print(df_plot_AC.head())

# Configurar o estilo do seaborn
sns.set_theme(style="whitegrid")

# Criar a figura e o eixo explicitamente
fig, ax = plt.subplots(figsize=(12, 6))

# Plotar usando seaborn, chamando lineplot for each desired column
sns.lineplot(
    data=df_plot,
    x="DATA_REF",
    y="VALOR_MINIMO", # Change 'VALORES' to 'VALOR_MINIMO'
    ax=ax,  # Especificar o eixo
    marker='o',  # Adicionar marcadores
    linewidth=2.5,  # Tornar a linha mais visível
    label='Valor Mínimo' # Add a label for the legend
)

sns.lineplot(
    data=df_plot,
    x="DATA_REF",
    y="VALOR_MEDIO", # Change 'VALORES' to 'VALOR_MEDIO'
    ax=ax,  # Especificar o eixo
    marker='o',  # Adicionar marcadores
    linewidth=2.5,  # Tornar a linha mais visível
    label='Valor Médio' # Add a label for the legend
)

sns.lineplot(
    data=df_plot,
    x="DATA_REF",
    y="VALOR_MAXIMO", # Change 'VALORES' to 'VALOR_MAXIMO'
    ax=ax,  # Especificar o eixo
    marker='o',  # Adicionar marcadores
    linewidth=2.5,  # Tornar a linha mais visível
    label='Valor Máximo' # Add a label for the legend
)

# Configurações adicionais
ax.set_title("Valores Mínimo, Médio e Máximo do Bolsa Família ao Longo do Tempo - Acre", pad=20)
ax.set_xlabel("Mês de Referência", labelpad=10)
ax.set_ylabel("Valores (R$)", labelpad=10)
ax.tick_params(axis='x', rotation=45)  # Rotacionar labels do eixo x

# Adicionar legenda
ax.legend()

# Ajustar layout para evitar cortes
plt.tight_layout()
plt.show()

sns.barplot(
    data=df_plot,
    x="DATA_REF",
    y="BENEFICIARIO", # Change 'VALORES' to 'Beneficiário'
    ax=ax,  # Especificar o eixo
)

# Configurações adicionais
ax.set_title("Quantidade de Beneficiários do Bolsa Família ao Longo do Tempo - Acre", pad=20)
ax.set_xlabel("Mês de Referência", labelpad=10)
ax.set_ylabel("Beneficiários", labelpad=10)
ax.tick_params(axis='x', rotation=45)  # Rotacionar labels do eixo x

# Ajustar layout para evitar cortes
plt.tight_layout()
plt.show()

# Certifique-se que os dados estão corretamente agrupados
df_agrupado_SE = sergipe.group_by("DATA_REF").agg(
    pl.col("VALOR").min().alias("VALOR_MINIMO").round(2),
    pl.col("VALOR").mean().alias("VALOR_MEDIO").round(2),
    pl.col("VALOR").max().alias("VALOR_MAXIMO").round(2),
    pl.col("NIS FAVORECIDO").count().alias("BENEFICIARIO").round(2)
).sort("DATA_REF")

# Converter para Pandas explicitamente
df_plot_SE = df_agrupado_SE.to_pandas()

# Verificar os dados que serão plotados
print("Dados para plotagem:")
print(df_plot_SE.head())

# Configurar o estilo do seaborn
sns.set_theme(style="whitegrid")

# Criar a figura e o eixo explicitamente
fig, ax = plt.subplots(figsize=(12, 6))

# Plotar usando seaborn, chamando lineplot for each desired column
sns.lineplot(
    data=df_plot,
    x="DATA_REF",
    y="VALOR_MINIMO", # Change 'VALORES' to 'VALOR_MINIMO'
    ax=ax,  # Especificar o eixo
    marker='o',  # Adicionar marcadores
    linewidth=2.5,  # Tornar a linha mais visível
    label='Valor Mínimo' # Add a label for the legend
)

sns.lineplot(
    data=df_plot,
    x="DATA_REF",
    y="VALOR_MEDIO", # Change 'VALORES' to 'VALOR_MEDIO'
    ax=ax,  # Especificar o eixo
    marker='o',  # Adicionar marcadores
    linewidth=2.5,  # Tornar a linha mais visível
    label='Valor Médio' # Add a label for the legend
)

sns.lineplot(
    data=df_plot,
    x="DATA_REF",
    y="VALOR_MAXIMO", # Change 'VALORES' to 'VALOR_MAXIMO'
    ax=ax,  # Especificar o eixo
    marker='o',  # Adicionar marcadores
    linewidth=2.5,  # Tornar a linha mais visível
    label='Valor Máximo' # Add a label for the legend
)

# Configurações adicionais
ax.set_title("Valores Mínimo, Médio e Máximo do Bolsa Família ao Longo do Tempo - Sergipe", pad=20)
ax.set_xlabel("Mês de Referência", labelpad=10)
ax.set_ylabel("Valores (R$)", labelpad=10)
ax.tick_params(axis='x', rotation=45)  # Rotacionar labels do eixo x

# Adicionar legenda
ax.legend()

# Ajustar layout para evitar cortes
plt.tight_layout()
plt.show()

sns.barplot(
    data=df_plot,
    x="DATA_REF",
    y="BENEFICIARIO", # Change 'VALORES' to 'Beneficiário'
    ax=ax,  # Especificar o eixo
)

# Configurações adicionais
ax.set_title("Quantidade de Beneficiários do Bolsa Família ao Longo do Tempo - Sergipe", pad=20)
ax.set_xlabel("Mês de Referência", labelpad=10)
ax.set_ylabel("Beneficiários", labelpad=10)
ax.tick_params(axis='x', rotation=45)  # Rotacionar labels do eixo x

# Ajustar layout para evitar cortes
plt.tight_layout()
plt.show()

# Certifique-se que os dados estão corretamente agrupados
df_agrupado_MS = mato_grosso_sul.group_by("DATA_REF").agg(
    pl.col("VALOR").min().alias("VALOR_MINIMO").round(2),
    pl.col("VALOR").mean().alias("VALOR_MEDIO").round(2),
    pl.col("VALOR").max().alias("VALOR_MAXIMO").round(2),
    pl.col("NIS FAVORECIDO").count().alias("BENEFICIARIO").round(2)
).sort("DATA_REF")

# Converter para Pandas explicitamente
df_plot_MS = df_agrupado_MS.to_pandas()

# Verificar os dados que serão plotados
print("Dados para plotagem:")
print(df_plot_MS.head())

# Configurar o estilo do seaborn
sns.set_theme(style="whitegrid")

# Criar a figura e o eixo explicitamente
fig, ax = plt.subplots(figsize=(12, 6))

# Plotar usando seaborn, chamando lineplot for each desired column
sns.lineplot(
    data=df_plot,
    x="DATA_REF",
    y="VALOR_MINIMO", # Change 'VALORES' to 'VALOR_MINIMO'
    ax=ax,  # Especificar o eixo
    marker='o',  # Adicionar marcadores
    linewidth=2.5,  # Tornar a linha mais visível
    label='Valor Mínimo' # Add a label for the legend
)

sns.lineplot(
    data=df_plot,
    x="DATA_REF",
    y="VALOR_MEDIO", # Change 'VALORES' to 'VALOR_MEDIO'
    ax=ax,  # Especificar o eixo
    marker='o',  # Adicionar marcadores
    linewidth=2.5,  # Tornar a linha mais visível
    label='Valor Médio' # Add a label for the legend
)

sns.lineplot(
    data=df_plot,
    x="DATA_REF",
    y="VALOR_MAXIMO", # Change 'VALORES' to 'VALOR_MAXIMO'
    ax=ax,  # Especificar o eixo
    marker='o',  # Adicionar marcadores
    linewidth=2.5,  # Tornar a linha mais visível
    label='Valor Máximo' # Add a label for the legend
)

# Configurações adicionais
ax.set_title("Valores Mínimo, Médio e Máximo do Bolsa Família ao Longo do Tempo - Mato Grosso do Sul", pad=20)
ax.set_xlabel("Mês de Referência", labelpad=10)
ax.set_ylabel("Valores (R$)", labelpad=10)
ax.tick_params(axis='x', rotation=45)  # Rotacionar labels do eixo x

# Adicionar legenda
ax.legend()

# Ajustar layout para evitar cortes
plt.tight_layout()
plt.show()

sns.barplot(
    data=df_plot,
    x="DATA_REF",
    y="BENEFICIARIO", # Change 'VALORES' to 'Beneficiário'
    ax=ax,  # Especificar o eixo
)

# Configurações adicionais
ax.set_title("Quantidade de Beneficiários do Bolsa Família ao Longo do Tempo - Mato Grosso do Sul", pad=20)
ax.set_xlabel("Mês de Referência", labelpad=10)
ax.set_ylabel("Beneficiários", labelpad=10)
ax.tick_params(axis='x', rotation=45)  # Rotacionar labels do eixo x

# Ajustar layout para evitar cortes
plt.tight_layout()
plt.show()

# 3 - MODELAGEM PREDITIVA

# 1. Converter para tipo Date do Polars se necessário
if df_agrupado["DATA_REF"].dtype != pl.Date:
    df_agrupado = df_agrupado.with_columns(
        pl.col("DATA_REF").cast(pl.Date)
    )

# 2. Calcular usando expressões puras do Polars
df_reg = df_agrupado.with_columns(
    (pl.col("DATA_REF").dt.year() * 12 + pl.col("DATA_REF").dt.month() -
     (pl.col("DATA_REF").min().dt.year() * 12 + pl.col("DATA_REF").min().dt.month()))
    .alias("MESES_DESDE_INICIO")
)

# 3. Verificar o resultado
print(df_reg.select(["DATA_REF", "MESES_DESDE_INICIO"]).head())

## 1. Preparar os dados para o modelo
# Converter para arrays numpy
X = df_reg["MESES_DESDE_INICIO"].to_numpy().reshape(-1, 1)  # Variável independente (meses)
y = df_reg["VALOR_MEDIO"].to_numpy()                        # Variável dependente (valor)

## 2. Criar e treinar o modelo
modelo = LinearRegression()
modelo.fit(X, y)

# Coeficientes do modelo
inclinacao = modelo.coef_[0]
intercepto = modelo.intercept_

print(f"Equação da reta: VALOR_MEDIO = {inclinacao:.2f} * MESES_DESDE_INICIO + {intercepto:.2f}")
print(f"Coeficiente angular (R$/mês): {inclinacao:.2f}")
print(f"Intercepto (valor inicial): R$ {intercepto:.2f}")

## 3. Fazer previsões
y_pred = modelo.predict(X)

## 4. Avaliar o modelo

r2 = r2_score(y, y_pred)
mse = mean_squared_error(y, y_pred)

print(f"\nMétricas de avaliação:")
print(f"Coeficiente de Determinação (R²): {r2:.4f}")
print(f"Erro Quadrático Médio (MSE): {mse:.2f}")

## 5. Visualização dos resultados
plt.figure(figsize=(10, 6))

# Plotar dados reais
plt.scatter(X, y, color='blue', label='Dados Reais')

# Plotar linha de regressão
plt.plot(X, y_pred, color='red', linewidth=2, label=f'Regressão: y = {inclinacao:.2f}x + {intercepto:.2f}')

# Configurações do gráfico
plt.title('Regressão Linear: Valor Médio vs Tempo (Meses)')
plt.xlabel('Meses desde o início')
plt.ylabel('Valor Médio (R$)')
plt.grid(True)
plt.legend()

# Mostrar gráfico
plt.tight_layout()
plt.show()

#Gráfico individual para cada estado

#ACRE

# 1. Converter para tipo Date do Polars se necessário
if df_agrupado_AC["DATA_REF"].dtype != pl.Date:
    df_agrupado_AC = df_agrupado_AC.with_columns(
        pl.col("DATA_REF").cast(pl.Date)
    )

# 2. Calcular usando expressões puras do Polars
df_reg_AC = df_agrupado_AC.with_columns(
    (pl.col("DATA_REF").dt.year() * 12 + pl.col("DATA_REF").dt.month() -
     (pl.col("DATA_REF").min().dt.year() * 12 + pl.col("DATA_REF").min().dt.month()))
    .alias("MESES_DESDE_INICIO")
)

# 3. Verificar o resultado
print(df_reg_AC.select(["DATA_REF", "MESES_DESDE_INICIO"]).head())

## 1. Preparar os dados para o modelo
# Converter para arrays numpy
X = df_reg_AC["MESES_DESDE_INICIO"].to_numpy().reshape(-1, 1)  # Variável independente (meses)
y = df_reg_AC["VALOR_MEDIO"].to_numpy()                        # Variável dependente (valor)

## 2. Criar e treinar o modelo
modelo_AC = LinearRegression()
modelo_AC.fit(X, y)

# Coeficientes do modelo
inclinacao_AC = modelo_AC.coef_[0]
intercepto_AC = modelo_AC.intercept_

print(f"Equação da reta: VALOR_MEDIO = {inclinacao_AC:.2f} * MESES_DESDE_INICIO + {intercepto_AC:.2f}")
print(f"Coeficiente angular (R$/mês): {inclinacao_AC:.2f}")
print(f"Intercepto (valor inicial): R$ {intercepto_AC:.2f}")

## 3. Fazer previsões
y_pred_AC = modelo_AC.predict(X)

## 4. Avaliar o modelo

r2_AC = r2_score(y, y_pred_AC)
mse_AC = mean_squared_error(y, y_pred_AC)

print(f"\nMétricas de avaliação:")
print(f"Coeficiente de Determinação (R²): {r2_AC:.4f}")
print(f"Erro Quadrático Médio (MSE): {mse_AC:.2f}")

## 5. Visualização dos resultados
plt.figure(figsize=(10, 6))

# Plotar dados reais
plt.scatter(X, y, color='blue', label='Dados Reais')

# Plotar linha de regressão
plt.plot(X, y_pred_AC, color='red', linewidth=2, label=f'Regressão: y = {inclinacao_AC:.2f}x + {intercepto_AC:.2f}')

# Configurações do gráfico
plt.title('Regressão Linear: Valor Médio vs Tempo (Meses) - Acre')
plt.xlabel('Meses desde o início')
plt.ylabel('Valor Médio (R$)')
plt.grid(True)
plt.legend()

# Mostrar gráfico
plt.tight_layout()
plt.show()

#SERGIPE

# 1. Converter para tipo Date do Polars se necessário
if df_agrupado_SE["DATA_REF"].dtype != pl.Date:
    df_agrupado_SE = df_agrupado_SE.with_columns(
        pl.col("DATA_REF").cast(pl.Date)
    )

# 2. Calcular usando expressões puras do Polars
df_reg_SE = df_agrupado_SE.with_columns(
    (pl.col("DATA_REF").dt.year() * 12 + pl.col("DATA_REF").dt.month() -
     (pl.col("DATA_REF").min().dt.year() * 12 + pl.col("DATA_REF").min().dt.month()))
    .alias("MESES_DESDE_INICIO")
)

# 3. Verificar o resultado
print(df_reg_SE.select(["DATA_REF", "MESES_DESDE_INICIO"]).head())

## 1. Preparar os dados para o modelo
# Converter para arrays numpy
X = df_reg_SE["MESES_DESDE_INICIO"].to_numpy().reshape(-1, 1)  # Variável independente (meses)
y = df_reg_SE["VALOR_MEDIO"].to_numpy()                        # Variável dependente (valor)

## 2. Criar e treinar o modelo
modelo_SE = LinearRegression()
modelo_SE.fit(X, y)

# Coeficientes do modelo
inclinacao_SE = modelo_SE.coef_[0]
intercepto_SE = modelo_SE.intercept_

print(f"Equação da reta: VALOR_MEDIO = {inclinacao_SE:.2f} * MESES_DESDE_INICIO + {intercepto_SE:.2f}")
print(f"Coeficiente angular (R$/mês): {inclinacao_SE:.2f}")
print(f"Intercepto (valor inicial): R$ {intercepto_SE:.2f}")

## 3. Fazer previsões
y_pred_SE = modelo_SE.predict(X)

## 4. Avaliar o modelo

r2_SE = r2_score(y, y_pred_SE)
mse_SE = mean_squared_error(y, y_pred_SE)

print(f"\nMétricas de avaliação:")
print(f"Coeficiente de Determinação (R²): {r2_SE:.4f}")
print(f"Erro Quadrático Médio (MSE): {mse_SE:.2f}")

## 5. Visualização dos resultados
plt.figure(figsize=(10, 6))

# Plotar dados reais
plt.scatter(X, y, color='blue', label='Dados Reais')

# Plotar linha de regressão
plt.plot(X, y_pred_SE, color='red', linewidth=2, label=f'Regressão: y = {inclinacao_SE:.2f}x + {intercepto_SE:.2f}')

# Configurações do gráfico
plt.title('Regressão Linear: Valor Médio vs Tempo (Meses) - Sergipe')
plt.xlabel('Meses desde o início')
plt.ylabel('Valores (R$)')
plt.grid(True)
plt.legend()

# Mostrar gráfico
plt.tight_layout()
plt.show()

#MATO GROSSO DO SUL

# 1. Converter para tipo Date do Polars se necessário
if df_agrupado_MS["DATA_REF"].dtype != pl.Date:
    df_agrupado_MS = df_agrupado_MS.with_columns(
        pl.col("DATA_REF").cast(pl.Date)
    )

# 2. Calcular usando expressões puras do Polars
df_reg_MS = df_agrupado_MS.with_columns(
    (pl.col("DATA_REF").dt.year() * 12 + pl.col("DATA_REF").dt.month() -
     (pl.col("DATA_REF").min().dt.year() * 12 + pl.col("DATA_REF").min().dt.month()))
    .alias("MESES_DESDE_INICIO")
)

# 3. Verificar o resultado
print(df_reg_MS.select(["DATA_REF", "MESES_DESDE_INICIO"]).head())

## 1. Preparar os dados para o modelo
# Converter para arrays numpy
X = df_reg_MS["MESES_DESDE_INICIO"].to_numpy().reshape(-1, 1)  # Variável independente (meses)
y = df_reg_MS["VALOR_MEDIO"].to_numpy()                        # Variável dependente (valor)

## 2. Criar e treinar o modelo
modelo_MS = LinearRegression()
modelo_MS.fit(X, y)

# Coeficientes do modelo
inclinacao_MS = modelo_MS.coef_[0]
intercepto_MS = modelo_MS.intercept_

print(f"Equação da reta: VALOR_MEDIO = {inclinacao_MS:.2f} * MESES_DESDE_INICIO + {intercepto_MS:.2f}")
print(f"Coeficiente angular (R$/mês): {inclinacao_MS:.2f}")
print(f"Intercepto (valor inicial): R$ {intercepto_MS:.2f}")

## 3. Fazer previsões
y_pred_MS = modelo_SE.predict(X)

## 4. Avaliar o modelo

r2_MS = r2_score(y, y_pred_MS)
mse_MS = mean_squared_error(y, y_pred_MS)

print(f"\nMétricas de avaliação:")
print(f"Coeficiente de Determinação (R²): {r2_MS:.4f}")
print(f"Erro Quadrático Médio (MSE): {mse_MS:.2f}")

## 5. Visualização dos resultados
plt.figure(figsize=(10, 6))

# Plotar dados reais
plt.scatter(X, y, color='blue', label='Dados Reais')

# Plotar linha de regressão
plt.plot(X, y_pred_MS, color='red', linewidth=2, label=f'Regressão: y = {inclinacao_MS:.2f}x + {intercepto_MS:.2f}')

# Configurações do gráfico
plt.title('Regressão Linear: Valor Médio vs Tempo (Meses) - Mato Grosso do Sul')
plt.xlabel('Meses desde o início')
plt.ylabel('Valor Médio (R$)')
plt.grid(True)
plt.legend()

# Mostrar gráfico
plt.tight_layout()
plt.show()

# Intervalo de Confiança 95% por Estado

# Versão Alternativa com intervalo de confiança:

plt.figure(figsize=(10, 6))
sns.regplot(x=X.flatten(), y=y, ci=95,
            line_kws={'color': 'red', 'label': f'y = {inclinacao:.2f}x + {intercepto:.2f}'})
plt.title('Regressão Linear com Intervalo de Confiança 95%')
plt.xlabel('Meses desde o início')
plt.ylabel('Valor Médio (R$)')
plt.legend()
plt.grid(True)
plt.show()

# Versão Alternativa com intervalo de confiança:

plt.figure(figsize=(10, 6))
sns.regplot(x=X.flatten(), y=y, ci=95,
            line_kws={'color': 'red', 'label': f'y = {inclinacao_AC:.2f}x + {intercepto_AC:.2f}'})
plt.title('Regressão Linear com Intervalo de Confiança 95% - Acre')
plt.xlabel('Meses desde o início')
plt.ylabel('Valor Médio (R$)')
plt.legend()
plt.grid(True)
plt.show()

# Versão Alternativa com intervalo de confiança:

plt.figure(figsize=(10, 6))
sns.regplot(x=X.flatten(), y=y, ci=95,
            line_kws={'color': 'red', 'label': f'y = {inclinacao_SE:.2f}x + {intercepto_SE:.2f}'})
plt.title('Regressão Linear com Intervalo de Confiança 95% - Sergipe')
plt.xlabel('Meses desde o início')
plt.ylabel('Valor Médio (R$)')
plt.legend()
plt.grid(True)
plt.show()

# Versão Alternativa com intervalo de confiança:

plt.figure(figsize=(10, 6))
sns.regplot(x=X.flatten(), y=y, ci=95,
            line_kws={'color': 'red', 'label': f'y = {inclinacao_MS:.2f}x + {intercepto_MS:.2f}'})
plt.title('Regressão Linear com Intervalo de Confiança 95% - Mato Grosso do Sul')
plt.xlabel('Meses desde o início')
plt.ylabel('Valor Médio (R$)')
plt.legend()
plt.grid(True)
plt.show()

# 4 - ANÁLISE COMPARATIVA

'''Durante o período de 8 meses ocorreu:

- Aumento da quantidade de beneficiários nos 3 estados;

- No estado do Acre o valor inicial do benefício mínimo foi de 350.00, o médio de 707.40 e o máximo de 1336.00;
- No estado do Acre o valor final do benefício mínimo foi de 300.00, o médio de 724.24 e o máximo de 2104.00;

- No estado de Sergipe o valor inicial do benefício mínimo foi de 700.00, o médio de 700.00 e o máximo de 700.00;
- No estado de Sergipe o valor final do benefício mínimo foi de 300.00, o médio de 627.89 e o máximo de 1728.00;

- No estado do Mato Grosso do Sul o valor inicial do benefício mínimo foi de 300.00, o médio de 300.00 e o máximo de 300.00;
- No estado do Mato Grosso do Sul o valor final do benefício mínimo foi de 300.00, o médio de 673.75 e o máximo de 1436.00;

- O valor inicial do benefício mínimo mais alto foi no estado de Sergipe;
- O valor inicial da média do benefício mais alto foi no estado do Acre;
- O valor inicial do benefício máximo mais alto foi no estado do Acre;

- O estado que teve maior o maior crescimento mensal em relação ao valor médio do benefício foi o Mato Grosso do Sul,
pois salto de 300.00 para 673.15 em 8 meses com um crescimento de 124.59% neste período;

- O Intervalo de Confiança demonstra a linha de tendência da função, pontuando os valores máximos e mínimos de cada período;
- O Intervalo de Confiança de 95 %  deixa a linha sempre próxima a média em cada período, pontuando também os valores máximos e mínimos,
e sombreia a faixa da margem de erro em um intervalo próximo à média;
- O Intervalo de Confiança é mais preciso para esta anállise, pois utiliza linha de tendência, máximos e mínimos.

'''